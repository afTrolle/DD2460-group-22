MODULE main
VAR
  location : array 0..3 of boolean;
  traveling: array 0..3 of boolean;
  torch: boolean;
  time: 0..100;

ASSIGN
  init (location[0]) := FALSE;
  init (location[1]) := FALSE;
  init (location[2]) := FALSE;
  init (location[3]) := FALSE;
 
  init (torch) := FALSE;
  init (time) := 0;

next (torch) := case
	
	torch = (count(traveling[0], traveling[1], traveling[2], traveling[3]) > 0) & torch: !torch;
	torch = (count(traveling[0], traveling[1], traveling[2], traveling[3]) > 0) & !torch: torch;

	torch = (count(traveling[0], traveling[1], traveling[2], traveling[3]) <= 0) & torch: torch;
	torch = (count(traveling[0], traveling[1], traveling[2], traveling[3]) <= 0) & !torch: !torch;

    -- rule: torch can only move if carried
  esac;

  next (location[0]) := case
    -- rule: location changes if "0" is traveling
	location[0] = traveling[0] & location[0] & torch :!location[0] & !traveling[0];

	location[0] = traveling[0] & location[0] & !torch :location[0] & !traveling[0];

	location[0] = traveling[0] & !location[0] & torch :!location[0] & !traveling[0];

	location[0] = traveling[0] & !location[0] & !torch :location[0] & !traveling[0];

	TRUE: location[0];
	

  esac;

  next (location[1]) := case
    -- copy rule from above and change index
	location[1] = traveling[1] & location[1] & torch :!location[1] & !traveling[1];

	location[1] = traveling[1] & location[1] & !torch :location[1] & !traveling[1];

	location[1] = traveling[1] & !location[1] & torch :!location[1] & !traveling[1];

	location[1] = traveling[1] & !location[1] & !torch :location[1] & !traveling[1];

	location[1] = !traveling[1] & location[1] & torch :!location[1] & !traveling[1];

	location[1] = !traveling[1] & location[1] & !torch :!location[1] & !traveling[1];

	location[1] = !traveling[1] & !location[1] & torch :!location[1] & !traveling[1];

	location[1] = !traveling[1] & !location[1] & !torch :!location[1] & !traveling[1];
	
  esac;

  next (location[2]) := case
	location[2] = traveling[2] & location[2] & torch :!location[2] & !traveling[2];

	location[2] = traveling[2] & location[2] & !torch :location[2] & !traveling[2];

	location[2] = traveling[2] & !location[2] & torch :!location[2] & !traveling[2];

	location[2] = traveling[2] & !location[2] & !torch :location[2] & !traveling[2];

	location[2] = !traveling[2] & location[2] & torch :!location[2] & !traveling[2];

	location[2] = !traveling[2] & location[2] & !torch :!location[2] & !traveling[2];

	location[2] = !traveling[2] & !location[2] & torch :!location[2] & !traveling[2];

	location[2] = !traveling[2] & !location[2] & !torch :!location[2] & !traveling[2];
	

  esac;

  next (location[3]) := case
	location[3] = traveling[3] & location[3] & torch :!location[3] & !traveling[3];

	location[3] = traveling[3] & location[3] & !torch :location[3] & !traveling[3];

	location[3] = traveling[3] & !location[3] & torch :!location[3] & !traveling[3];

	location[3] = traveling[3] & !location[3] & !torch :location[3] & !traveling[3];

	location[3] = !traveling[3] & location[3] & torch :!location[3] & !traveling[3];

	location[3] = !traveling[3] & location[3] & !torch :!location[3] & !traveling[3];

	location[3] = !traveling[3] & !location[3] & torch :!location[3] & !traveling[3];

	location[3] = !traveling[3] & !location[3] & !torch :!location[3] & !traveling[3];
	
	
  esac;

  

  next(time) := case
    time > 90: 90;

    traveling[3]: time + 10;
	traveling[2]: time + 5;
	traveling[1]: time + 2;
	traveling[0]: time + 1;
	TRUE: time;
 
  esac;





	

LTLSPEC
  !(G(count(traveling[0], traveling[1], traveling[2], traveling[3]) <= 2 ) &
G(location[0] & location[1] & location[2] & location[3] -> torch) & 
G(traveling[0] -> F(location[0] != next(location[0]))) &
G(traveling[1] -> F(location[1] != next(location[1]))) &
G(traveling[2] -> F(location[2] != next(location[2]))) &
G(traveling[3] -> F(location[3] != next(location[3]))) 
U (location[0] & location[1] & location[2] & location[3] & torch));

/-- (count(traveling[0], traveling[1], traveling[2], traveling[3]) = 2) -> (count(location[0] != next(location[0]), location[1] != next(location[1]), location[2] != next(location[2]), location[3] != next(location[3])) = 2) --/	
  

